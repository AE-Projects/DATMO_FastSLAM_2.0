clear
clc
close all;

% Parameter Initialization
verbose = 3; % verbose = 0: no visual output, 1: only visual output in the end, 2: all visual output
%verbose = 0; % verbose = 0: no visual output, 1: estimates and/or odometry and/or groundtruth, 2: (1)+ extra info, 3: (2)+ observation lines

ITERATIONS = 20;
CONVERGE = 1e-03;
PAUSEDURATION = 2000 / 1000; % Seconds



% this is the output of the simlator butis the input to the SLAM
% program.  It summarizes the simulated measurements based on the map and trajectory. 
%We mainly want to grab the odometry that was generated by the simulation add some 
% estimated covariance to it and use it to make motion factors.  
%Then use the range and bearing to landmarks to make factors between poses
%and landmarks.  

%Coment out all but one pair of files

%A small map with four landmarks 
simOutFile = 'so_sym2_nk_wmov.txt';
mapFile = 'map_sym2.txt';
load('mov_obj_pos.mat')
% a larger, denser map but less noise
%simOutFile = 'so_o3_ie.txt';
%mapFile = 'map_o3.txt';

%A small map with five landmarks 
%simOutFile = 'so_sym3_nk.txt';
%mapFile = 'map_sym3.txt';


% here the noise is so large that you will not get convergence without
% modifications to the approach (for example outlier detection)
%simOutFile = 'so_pb_10_outlier.txt';
%mapFile = 'map_pent_big_10.txt';

% here we have no odometry at all so the initial estimate can not be made
% beyond the features seen at the start  It is intersting to see the local
% minima it finds.
%simOutFile = 'so_pb_40_no.txt';
%mapFile = 'map_pent_big_40.txt';



% This init mainly just choses a good starting value for R the odometery 
% covariance and Q the range bearing Covariance base on the filename.             
[muRob0,sigma,R,Q,~] = init(simOutFile);
E_T = 2048;
B = 0.35;
R_L = 0.1;
R_R = 0.1;

%%
% Code initialization
datasetBase = 'DataSets/';
%Start by reading in the true map into a matrix
d = load([datasetBase mapFile]);

map = d(:,2:3)';
%map = cat(1,map,d(:,1)'); % Add id of the landmarks to map matrix
mapIds = d(:,1)';

% Now for the measurment data we have different lengths for each line in
% the file so we must work harder to load them line by line.
fid = fopen([datasetBase simOutFile],'r');
if fid <= 0
  fprintf('Failed to open simoutput file "%s"\n',simOutFile);
  return
end

simSteps = {};
while 1
    line = fgetl(fid);
    if ~ischar(line)
        break
    end
    values = sscanf(line, '%f');
    %notice that we call the creator from the SimStep Class here to parse
    %this into a 'SimStep' object.
    simSteps = {simSteps{:} SimStep(values)}; %#ok
end
fclose(fid);

%%
% Graph SLAM initialize a set of pose nodes at poses in muRob bsed on the
%odometry alone. 
numPoses = size(simSteps,2);
%odo = odometry(simSteps,E_T,B,R_L, R_R);
n_timesteps = size(simSteps,2);
mu_pos = simSteps{1}.truePose;
mu_pos_arr = zeros(3, n_timesteps-1);
odom_true = zeros(3, n_timesteps-1);
slam_pose = zeros(3, n_timesteps-1);
pose_true = zeros(3, n_timesteps-1);
mov_path_pred = zeros(2, n_timesteps-1);
u_arr = zeros(3, n_timesteps-1);
P_t = [0.1 0 0; 0 0.1 0; 0 0 deg2rad(1)];
S_t = [0.1 0; 0 0.1];
% Initialize mu and sigma
mu_0 = zeros(3,1);
sigma_0 = zeros(3,3);
mu_t_1 = mu_0;
sigma_t_1 = sigma_0;
N_0 = 0;
N_t_1 = N_0;
first_detect = 0;
%Main Loop
for t = 2:n_timesteps
    % e_R = simSteps{t}.encoder(1) - simSteps{t-1}.encoder(1);
    % e_L = simSteps{t}.encoder(2) - simSteps{t-1}.encoder(2);
    % delta_t = simSteps{t}.t - simSteps{t-1}.t;
    % odom_true(:,t) = simSteps{t}.odometry;
    pose_true(:,t) = simSteps{t}.truePose;
    % u = calculate_odometry(e_R, e_L, E_T, B, R_L, R_R, delta_t, mu_pos);
    % u_arr(:,t) = u;
    % mu_pos = u + mu_pos_arr(:,t-1);
    % mu_pos(3) = mod(mu_pos(3)+pi, 2*pi) - pi;
    % mu_pos_arr(:,t) = mu_pos;


    %New approach%
    fprintf('Simulation step: %d \n', t);
    e_R = simSteps{t}.encoder(1) - simSteps{t-1}.encoder(1);
    e_L = simSteps{t}.encoder(2) - simSteps{t-1}.encoder(2);
    u_t = [e_R; e_L];
    delta_t = simSteps{t}.t - simSteps{t-1}.t;
    z_t = simSteps{t}.seenLandmarks;
    z_t = z_t(1:3,:);
    mov_idx = find(z_t(3,:) < 0);
    if ~isempty(mov_idx)
        first_detect = first_detect + 1;
    end
    z_t_m = z_t(1:2, mov_idx);
    z_t_s = z_t(1:2,:);
    z_t_s(:,mov_idx) = [];
    %Define z_t_m
    [mu_t, sigma_t, N_t] = ekf_slam_datmo_func(mu_t_1, sigma_t_1, u_t, z_t_s, N_t_1,delta_t, R, Q);
    mu_t_rob = mu_t(1:3,1);
    sigma_t_rob = sigma_t(1:3, 1:3);
    if first_detect==1 
        theta0 = 1.2;
        mu_0_m = mu_t_rob + [z_t_m(1,1)*cos(z_t_m(2,1)); z_t_m(1,1)*sin(z_t_m(2,1)); theta0];
        sigma_0_m = 10^-1*eye(3,3);
        [mu_t_m, sigma_t_m] = datmo_func(mu_0_m, sigma_0_m, mu_t_rob, sigma_t_rob, z_t_m, P_t, S_t, delta_t);
        first_detect = 2;
        fprintf('First time detected')
    elseif first_detect>1
        [mu_t_m, sigma_t_m] = datmo_func(mu_t_1_m, sigma_t_1_m, mu_t_rob, sigma_t_rob, z_t_m, P_t, S_t, delta_t);
    end
    
    %fprintf('Robot X: %f, Y: %f, theta: %f \n', mu_t(1,1), mu_t(2,1), mu_t(3,1))
    %fprintf('True X: %f, Y: %f, theta: %f \n', pose_true(1,t), pose_true(2,t), pose_true(3,t))
    N_t_1 = N_t;
    mu_t_1 = mu_t;
    slam_pose(:,t) = mu_t_1(1:3,1);
    sigma_t_1 = sigma_t;
    mu_t_1_m = mu_t_m;
    sigma_t_1_m = sigma_t_m;
    mov_path_pred(:,t) = mu_t_1_m(1:2,1);
    color = 'b';
    sigma_max = 10^10;
    sigma_plot = min(sigma_max, max(sigma_t(1:2, 1:2), -sigma_max));
    mu_features_plot = reshape(mu_t(4:end), 2,N_t_1)';
    mu_plot = [mu_t(1:2,1)'; mu_features_plot];
    plot_SLAM_DATMO(map, simSteps{t}.truePose, z_t_s, z_t_m, [xm(1,t);ym(1,t)], sigma_t_1, mu_plot, sigma_t_m, mu_t_m, color)
    drawnow;
    hold on
end

%plot(mu_pos_arr(1,:));

hold on
%plot(odom_true(1,:))
%plot(v_arr(3,:));
%plot(pose_true(3,:))
%legend('odom main','odom true','odom path', 'true path')
figure()
plot(pose_true(1,:), pose_true(2,:), 'LineWidth', 1.5);
hold on
grid on
scatter(map(1,:), map(2,:))
plot(slam_pose(1,:), slam_pose(2,:), 'LineWidth', 1.5)
scatter(mu_t(4:2:end-1,1), mu_t(5:2:end, 1), 'k+', 'LineWidth', 1.5)
plot(mov_path_pred(1,:), mov_path_pred(2,:), 'LineWidth', 1.5)
plot(xm,ym, 'LineWidth', 1.5, 'LineStyle','--')
legend('True Path', 'True Features', 'SLAM Path', 'SLAM Features', 'DATMO', 'Move True')
%plot(odom_true(1,:), odom_true(2,:))

% muRob = graph_slam_initialize(simSteps, muRob0,odo);
% muMap = zeros(size(map));
% % For plotting results
% truePose = zeros(3, size(simSteps, 2));
% odometry = truePose;
% for i = 1:size(simSteps, 2)
%     truePose(:,i) = simSteps{i}.truePose;
%     odometry(:,i) = simSteps{i}.odometry;
% end
% finish=[1, numPoses];
% 
% %temp=round(numPoses/8,0);
% %finish=[1,temp*[1:7], numPoses];
% 
% for subpart=1:size(finish,2)-1
% % Group robot poses that have seen the same landmark j (function is defined
% % in aux folder)  This tau uses the known data associations and is to be 
% % later used  in the optimizer.
% % We also initialize the map to the first time each landmark is seen
% % to where it was according to the odometry.
% for j=1:finish(subpart)
%     %We use previous loop's estiate instead of odometry to initialize muMap
%     simSteps{j}.odometry=muRob(:,j);
% end
% muRob=[muRob zeros(3,finish(subpart+1)-size(muRob,2))];
% for t=(finish(subpart)+1):finish(subpart+1)
%         a=muRob(3,t-1);
%         du = [odo(1,t-1)*cos(a);
%         odo(1,t-1)*sin(a);
%         odo(2,t-1)];      
%         muRob(:,t)=muRob(:,t-1)+du;
%         simSteps{t}.odometry=muRob(:,t);    
% end    
% [tau muMap]= createTau(mapIds, simSteps,odo,finish(subpart+1));
% 
% %%
% % Graph SLAM main loop
% graphSlam = figure('Name','GraphSLAM');
% diff = [];
% hold on 
% plot_graph_slam(muRob,muMap,map,truePose,odometry,true,true,true,true,true,true);
% title('Initial Map and Trajectory  (in Red)');
%  subpart
% %pause
% for it = 1:ITERATIONS
%     % Save previous estimate
%     prevMuRob = muRob(:,1:finish(subpart+1));
% 
%     % Graph SLAM linearize
%     [Omega, Xi] = graph_slam_linearize(muRob, simSteps, muMap, R, Q, mapIds, odo,finish(subpart+1));
% 
%     % Graph SLAM reduce
%     [OmegaRed, XiRed] = graph_slam_reduce(Omega, Xi, tau, mapIds);
%     OmegaRed(:,:,3,3)
%     XiRed(:,3)'
%     pause  
%     % Graph SLAM solve robot
%     [muRob, SigmaRob] = graph_slam_solve_rob(OmegaRed, XiRed);
% 
%     % GraphSLAM solve map
%     if verbose >= 2 || it == ITERATIONS
%         [muMap] = graph_slam_solve_map(muRob, Omega, Xi, tau, mapIds);
%     end
%     % Update diff. between current and previous estimate
%     currentDiff = prevMuRob - muRob;
%     currentDiff(3,:) = mod(currentDiff(3,:)+pi,2*pi)-pi;
%     currentDiff = abs(sum(sum(currentDiff)));
% 
%     % Compute error between current estimate and ground truth
%     globalError = truePose(:,1:finish(subpart+1)) - muRob(:,1:finish(subpart+1));
%     globalError(3,:) = mod(globalError(3,:)+pi,2*pi)-pi;
%     diff = [diff abs(sum(sum(globalError)))/finish(subpart+1)];
% 
% 
%     % Check if it has converged
%     if  currentDiff <= CONVERGE
%         if verbose < 2
%             [muMap] = graph_slam_solve_map(muRob, Omega, Xi, tau, mapIds);
%         end
%         break;
%     end
% 
%     % Plot gth and recovered maps
%     if verbose >= 2
%         clf;
%         hold on 
%         plot_graph_slam(muRob,muMap,map,truePose,odometry,true,true,true,true,true,true);
%        title(it);
%         pause(PAUSEDURATION);
%     end
% end
% hold off
% 
% 
% fprintf('\n');
% 
% %%
% % Plot gth and recovered maps
% if verbose >= 1
%     close all;
%     hold on 
%     plot_graph_slam(muRob,muMap,map,truePose,odometry,true,true,true,true,true,true);
%     title('Final Map and Trajectory')
%     hold off
% end
% 
% %%
% % Plot the error
% 
% steps = size(simSteps,2);
% if steps>finish(subpart+1)
%     steps=finish(subpart+1);
% end
% errpose = zeros(3, steps);
% for i = 1:steps
%     errpose(:,i) = simSteps{i}.truePose(:) - muRob(:,i);
%     errpose(3,i) = mod(errpose(3,i)+pi,2*pi)-pi;
% end
% 
% maex = mean(abs(errpose(1,:)));
% mex = mean(errpose(1,:));
% maey = mean(abs(errpose(2,:)));
% mey = mean(errpose(2,:));
% maet = mean(abs(errpose(3,:)));
% met = mean(errpose(3,:));
% display(sprintf('mean error(x, y, theta)=(%f, %f, %f)\nmean absolute error=(%f, %f, %f)\n',mex,mey,met, maex,maey,maet));
% 
% if verbose >= 1
%     figure('Name', 'GraphSLAM: Pose error vs travel time');
%     clf;
%     subplot(3,1,1);
%     plot(errpose(1,:));
%     title(sprintf('error on x, mean error=%f, mean absolute err=%f',mex,maex));
%     subplot(3,1,2);
%     plot(errpose(2,:));
%     title(sprintf('error on y, mean error=%f, mean absolute err=%f',mey,maey));
%     subplot(3,1,3);
%     plot(errpose(3,:));
%     title(sprintf('error on theta, mean error=%f, mean absolute err=%f',met,maet));
% 
%     figure('Name', 'GraphSLAM: Sigma');
%     clf;
%     subplot(3,1,1);
%     plot(squeeze(SigmaRob(1,1,:,:)));
%     title('\Sigma(1,1)');
%     subplot(3,1,2);
%     plot(squeeze(SigmaRob(2,2,:,:)));
%     title('\Sigma(2,2)');
%     subplot(3,1,3);
%     plot(squeeze(SigmaRob(3,3,:,:)));
%     title('\Sigma(3,3)');
% 
%     figure('Name', 'GraphSLAM: global error');
%     clf;
%     plot(diff);
% end
% end